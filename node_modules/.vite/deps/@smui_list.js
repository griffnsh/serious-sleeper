import "./chunk-J7F4NX7A.js";
import {
  MDCListFoundation
} from "./chunk-MTCNSGUH.js";
import {
  classAdderBuilder
} from "./chunk-3VJ7PEFX.js";
import {
  dist_default
} from "./chunk-6JZXFK6W.js";
import "./chunk-CTXZTH3U.js";
import "./chunk-W4OU4FMO.js";
import "./chunk-UQY73DL2.js";
import "./chunk-JENRPHSG.js";
import {
  A,
  Div,
  H3,
  Hr,
  Li,
  Nav,
  Span,
  Ul
} from "./chunk-4QFZLL5E.js";
import "./chunk-FSFLYZXX.js";
import "./chunk-4DZS5E3S.js";
import "./chunk-KDQUT4KZ.js";
import {
  ponyfill_exports
} from "./chunk-2TKIVU2J.js";
import "./chunk-TCBN2E7P.js";
import {
  classMap,
  dispatch,
  forwardEventsBuilder,
  useActions
} from "./chunk-7JGAO77Z.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  mount_component,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-F3NZ3QLJ.js";
import "./chunk-SSYGV25P.js";

// node_modules/@smui/list/dist/List.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[37].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: `(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-deprecated-list': true,     'mdc-deprecated-list--non-interactive': nonInteractive,     'mdc-deprecated-list--dense': dense,     'mdc-deprecated-list--textual-list': textualList,     'mdc-deprecated-list--avatar-list': avatarList || selectionDialog,     'mdc-deprecated-list--icon-list': iconList,     'mdc-deprecated-list--image-list': imageList,     'mdc-deprecated-list--thumbnail-list': thumbnailList,     'mdc-deprecated-list--video-list': videoList,     'mdc-deprecated-list--two-line': twoLine,     'smui-list--three-line': threeLine && !twoLine,   })}   {role}   on:keydown={(event) =>     instance &&     instance.handleKeydown(       event,       event.target.classList.contains('mdc-deprecated-list-item'),       getListItemIndex(event.target)     )}   on:focusin={(event) =>     instance && instance.handleFocusIn(getListItemIndex(event.target))}   on:focusout={(event) =>     instance && instance.handleFocusOut(getListItemIndex(event.target))}   on:click={(event) =>     instance &&     instance.handleClick(       getListItemIndex(event.target),       !matches(event.target, 'input[type=\\"checkbox\\"], input[type=\\"radio\\"]')     )}   on:SMUIListItem:mount={handleItemMount}   on:SMUIListItem:unmount={handleItemUnmount}   on:SMUI:action={handleAction}   {...$$restProps} >`,
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx[17],
        .../*use*/
        ctx[0]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-list": true,
        "mdc-deprecated-list--non-interactive": (
          /*nonInteractive*/
          ctx[2]
        ),
        "mdc-deprecated-list--dense": (
          /*dense*/
          ctx[3]
        ),
        "mdc-deprecated-list--textual-list": (
          /*textualList*/
          ctx[4]
        ),
        "mdc-deprecated-list--avatar-list": (
          /*avatarList*/
          ctx[5] || /*selectionDialog*/
          ctx[18]
        ),
        "mdc-deprecated-list--icon-list": (
          /*iconList*/
          ctx[6]
        ),
        "mdc-deprecated-list--image-list": (
          /*imageList*/
          ctx[7]
        ),
        "mdc-deprecated-list--thumbnail-list": (
          /*thumbnailList*/
          ctx[8]
        ),
        "mdc-deprecated-list--video-list": (
          /*videoList*/
          ctx[9]
        ),
        "mdc-deprecated-list--two-line": (
          /*twoLine*/
          ctx[10]
        ),
        "smui-list--three-line": (
          /*threeLine*/
          ctx[11] && !/*twoLine*/
          ctx[10]
        )
      })
    },
    { role: (
      /*role*/
      ctx[15]
    ) },
    /*$$restProps*/
    ctx[23]
  ];
  var switch_value = (
    /*component*/
    ctx[12]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[38](switch_instance);
    switch_instance.$on(
      "keydown",
      /*keydown_handler*/
      ctx[39]
    );
    switch_instance.$on(
      "focusin",
      /*focusin_handler*/
      ctx[40]
    );
    switch_instance.$on(
      "focusout",
      /*focusout_handler*/
      ctx[41]
    );
    switch_instance.$on(
      "click",
      /*click_handler*/
      ctx[42]
    );
    switch_instance.$on(
      "SMUIListItem:mount",
      /*handleItemMount*/
      ctx[19]
    );
    switch_instance.$on(
      "SMUIListItem:unmount",
      /*handleItemUnmount*/
      ctx[20]
    );
    switch_instance.$on(
      "SMUI:action",
      /*handleAction*/
      ctx[21]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*forwardEvents, use, className, nonInteractive, dense, textualList, avatarList, selectionDialog, iconList, imageList, thumbnailList, videoList, twoLine, threeLine, role, $$restProps*/
      8818687 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*forwardEvents, use*/
        131073 && {
          use: [
            /*forwardEvents*/
            ctx2[17],
            .../*use*/
            ctx2[0]
          ]
        },
        dirty[0] & /*className, nonInteractive, dense, textualList, avatarList, selectionDialog, iconList, imageList, thumbnailList, videoList, twoLine, threeLine*/
        266238 && {
          class: classMap({
            [
              /*className*/
              ctx2[1]
            ]: true,
            "mdc-deprecated-list": true,
            "mdc-deprecated-list--non-interactive": (
              /*nonInteractive*/
              ctx2[2]
            ),
            "mdc-deprecated-list--dense": (
              /*dense*/
              ctx2[3]
            ),
            "mdc-deprecated-list--textual-list": (
              /*textualList*/
              ctx2[4]
            ),
            "mdc-deprecated-list--avatar-list": (
              /*avatarList*/
              ctx2[5] || /*selectionDialog*/
              ctx2[18]
            ),
            "mdc-deprecated-list--icon-list": (
              /*iconList*/
              ctx2[6]
            ),
            "mdc-deprecated-list--image-list": (
              /*imageList*/
              ctx2[7]
            ),
            "mdc-deprecated-list--thumbnail-list": (
              /*thumbnailList*/
              ctx2[8]
            ),
            "mdc-deprecated-list--video-list": (
              /*videoList*/
              ctx2[9]
            ),
            "mdc-deprecated-list--two-line": (
              /*twoLine*/
              ctx2[10]
            ),
            "smui-list--three-line": (
              /*threeLine*/
              ctx2[11] && !/*twoLine*/
              ctx2[10]
            )
          })
        },
        dirty[0] & /*role*/
        32768 && { role: (
          /*role*/
          ctx2[15]
        ) },
        dirty[0] & /*$$restProps*/
        8388608 && get_spread_object(
          /*$$restProps*/
          ctx2[23]
        )
      ]) : {};
      if (dirty[1] & /*$$scope*/
      4096) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty[0] & /*component*/
      4096 && switch_value !== (switch_value = /*component*/
      ctx2[12])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[38](switch_instance);
          switch_instance.$on(
            "keydown",
            /*keydown_handler*/
            ctx2[39]
          );
          switch_instance.$on(
            "focusin",
            /*focusin_handler*/
            ctx2[40]
          );
          switch_instance.$on(
            "focusout",
            /*focusout_handler*/
            ctx2[41]
          );
          switch_instance.$on(
            "click",
            /*click_handler*/
            ctx2[42]
          );
          switch_instance.$on(
            "SMUIListItem:mount",
            /*handleItemMount*/
            ctx2[19]
          );
          switch_instance.$on(
            "SMUIListItem:unmount",
            /*handleItemUnmount*/
            ctx2[20]
          );
          switch_instance.$on(
            "SMUI:action",
            /*handleAction*/
            ctx2[21]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[38](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "nonInteractive",
    "dense",
    "textualList",
    "avatarList",
    "iconList",
    "imageList",
    "thumbnailList",
    "videoList",
    "twoLine",
    "threeLine",
    "vertical",
    "wrapFocus",
    "singleSelection",
    "selectedIndex",
    "radioList",
    "checkList",
    "hasTypeahead",
    "component",
    "layout",
    "setEnabled",
    "getTypeaheadInProgress",
    "getSelectedIndex",
    "getFocusedItemIndex",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["default"]);
  var _a;
  const { closest, matches } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { nonInteractive = false } = $$props;
  let { dense = false } = $$props;
  let { textualList = false } = $$props;
  let { avatarList = false } = $$props;
  let { iconList = false } = $$props;
  let { imageList = false } = $$props;
  let { thumbnailList = false } = $$props;
  let { videoList = false } = $$props;
  let { twoLine = false } = $$props;
  let { threeLine = false } = $$props;
  let { vertical = true } = $$props;
  let { wrapFocus = (_a = getContext("SMUI:list:wrapFocus")) !== null && _a !== void 0 ? _a : false } = $$props;
  let { singleSelection = false } = $$props;
  let { selectedIndex = -1 } = $$props;
  let { radioList = false } = $$props;
  let { checkList = false } = $$props;
  let { hasTypeahead = false } = $$props;
  let element2;
  let instance5;
  let items = [];
  let role = getContext("SMUI:list:role");
  let nav = getContext("SMUI:list:nav");
  const itemAccessorMap = /* @__PURE__ */ new WeakMap();
  let selectionDialog = getContext("SMUI:dialog:selection");
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let { component = nav ? Nav : Ul } = $$props;
  setContext("SMUI:list:nonInteractive", nonInteractive);
  setContext("SMUI:separator:context", "list");
  if (!role) {
    if (singleSelection) {
      role = "listbox";
      setContext("SMUI:list:item:role", "option");
    } else if (radioList) {
      role = "radiogroup";
      setContext("SMUI:list:item:role", "radio");
    } else if (checkList) {
      role = "group";
      setContext("SMUI:list:item:role", "checkbox");
    } else {
      role = "list";
      setContext("SMUI:list:item:role", void 0);
    }
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(13, instance5 = new MDCListFoundation({
      addClassForElementIndex,
      focusItemAtIndex,
      getAttributeForElementIndex: (index, name) => {
        var _a2, _b;
        return (_b = (_a2 = getOrderedList()[index]) === null || _a2 === void 0 ? void 0 : _a2.getAttr(name)) !== null && _b !== void 0 ? _b : null;
      },
      getFocusedElementIndex: () => document.activeElement ? getOrderedList().map((accessor2) => accessor2.element).indexOf(document.activeElement) : -1,
      getListItemCount: () => items.length,
      getPrimaryTextAtIndex,
      hasCheckboxAtIndex: (index) => {
        var _a2, _b;
        return (_b = (_a2 = getOrderedList()[index]) === null || _a2 === void 0 ? void 0 : _a2.hasCheckbox) !== null && _b !== void 0 ? _b : false;
      },
      hasRadioAtIndex: (index) => {
        var _a2, _b;
        return (_b = (_a2 = getOrderedList()[index]) === null || _a2 === void 0 ? void 0 : _a2.hasRadio) !== null && _b !== void 0 ? _b : false;
      },
      isCheckboxCheckedAtIndex: (index) => {
        var _a2;
        const listItem = getOrderedList()[index];
        return (_a2 = (listItem === null || listItem === void 0 ? void 0 : listItem.hasCheckbox) && listItem.checked) !== null && _a2 !== void 0 ? _a2 : false;
      },
      isFocusInsideList: () => element2 != null && getElement() !== document.activeElement && getElement().contains(document.activeElement),
      isRootFocused: () => element2 != null && document.activeElement === getElement(),
      listItemAtIndexHasClass,
      notifyAction: (index) => {
        $$invalidate(24, selectedIndex = index);
        if (element2 != null) {
          dispatch(getElement(), "SMUIList:action", { index }, void 0, true);
        }
      },
      removeClassForElementIndex,
      setAttributeForElementIndex,
      setCheckedCheckboxOrRadioAtIndex: (index, isChecked) => {
        getOrderedList()[index].checked = isChecked;
      },
      setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
        const listItem = getOrderedList()[listItemIndex];
        const selector = "button:not(:disabled), a";
        Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
          el.setAttribute("tabindex", tabIndexValue);
        });
      }
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      get items() {
        return items;
      },
      get typeaheadInProgress() {
        return instance5.isTypeaheadInProgress();
      },
      typeaheadMatchItem(nextChar, startingIndex) {
        return instance5.typeaheadMatchItem(
          nextChar,
          startingIndex,
          /** skipFocus */
          true
        );
      },
      getOrderedList,
      focusItemAtIndex,
      addClassForElementIndex,
      removeClassForElementIndex,
      setAttributeForElementIndex,
      removeAttributeForElementIndex,
      getAttributeFromElementIndex,
      getPrimaryTextAtIndex
    };
    dispatch(getElement(), "SMUIList:mount", accessor);
    instance5.init();
    return () => {
      instance5.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function handleItemMount(event) {
    items.push(event.detail);
    itemAccessorMap.set(event.detail.element, event.detail);
    if (singleSelection && event.detail.selected) {
      $$invalidate(24, selectedIndex = getListItemIndex(event.detail.element));
    }
    event.stopPropagation();
  }
  function handleItemUnmount(event) {
    var _a2;
    const idx = (_a2 = event.detail && items.indexOf(event.detail)) !== null && _a2 !== void 0 ? _a2 : -1;
    if (idx !== -1) {
      items.splice(idx, 1);
      items = items;
      itemAccessorMap.delete(event.detail.element);
    }
    event.stopPropagation();
  }
  function handleAction(event) {
    if (radioList || checkList) {
      const index = getListItemIndex(event.target);
      if (index !== -1) {
        const item = getOrderedList()[index];
        if (item && (radioList && !item.checked || checkList)) {
          item.checked = !item.checked;
          item.activateRipple();
          window.requestAnimationFrame(() => {
            item.deactivateRipple();
          });
        }
      }
    }
  }
  function getOrderedList() {
    if (element2 == null) {
      return [];
    }
    return [...getElement().children].map((element3) => itemAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_list_item_accessor);
  }
  function focusItemAtIndex(index) {
    const accessor = getOrderedList()[index];
    accessor && "focus" in accessor.element && accessor.element.focus();
  }
  function listItemAtIndexHasClass(index, className2) {
    var _a2;
    const accessor = getOrderedList()[index];
    return (_a2 = accessor && accessor.hasClass(className2)) !== null && _a2 !== void 0 ? _a2 : false;
  }
  function addClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addClass(className2);
  }
  function removeClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeClass(className2);
  }
  function setAttributeForElementIndex(index, name, value) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addAttr(name, value);
  }
  function removeAttributeForElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeAttr(name);
  }
  function getAttributeFromElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    if (accessor) {
      return accessor.getAttr(name);
    } else {
      return null;
    }
  }
  function getPrimaryTextAtIndex(index) {
    var _a2;
    const accessor = getOrderedList()[index];
    return (_a2 = accessor && accessor.getPrimaryText()) !== null && _a2 !== void 0 ? _a2 : "";
  }
  function getListItemIndex(element3) {
    const nearestParent = closest(element3, ".mdc-deprecated-list-item, .mdc-deprecated-list");
    if (nearestParent && matches(nearestParent, ".mdc-deprecated-list-item")) {
      return getOrderedList().map((item) => item === null || item === void 0 ? void 0 : item.element).indexOf(nearestParent);
    }
    return -1;
  }
  function layout() {
    return instance5.layout();
  }
  function setEnabled(itemIndex, isEnabled) {
    return instance5.setEnabled(itemIndex, isEnabled);
  }
  function getTypeaheadInProgress() {
    return instance5.isTypeaheadInProgress();
  }
  function getSelectedIndex() {
    return instance5.getSelectedIndex();
  }
  function getFocusedItemIndex() {
    return instance5.getFocusedItemIndex();
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(14, element2);
    });
  }
  const keydown_handler = (event) => instance5 && instance5.handleKeydown(event, event.target.classList.contains("mdc-deprecated-list-item"), getListItemIndex(event.target));
  const focusin_handler = (event) => instance5 && instance5.handleFocusIn(getListItemIndex(event.target));
  const focusout_handler = (event) => instance5 && instance5.handleFocusOut(getListItemIndex(event.target));
  const click_handler = (event) => instance5 && instance5.handleClick(getListItemIndex(event.target), !matches(event.target, 'input[type="checkbox"], input[type="radio"]'));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("nonInteractive" in $$new_props)
      $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    if ("dense" in $$new_props)
      $$invalidate(3, dense = $$new_props.dense);
    if ("textualList" in $$new_props)
      $$invalidate(4, textualList = $$new_props.textualList);
    if ("avatarList" in $$new_props)
      $$invalidate(5, avatarList = $$new_props.avatarList);
    if ("iconList" in $$new_props)
      $$invalidate(6, iconList = $$new_props.iconList);
    if ("imageList" in $$new_props)
      $$invalidate(7, imageList = $$new_props.imageList);
    if ("thumbnailList" in $$new_props)
      $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
    if ("videoList" in $$new_props)
      $$invalidate(9, videoList = $$new_props.videoList);
    if ("twoLine" in $$new_props)
      $$invalidate(10, twoLine = $$new_props.twoLine);
    if ("threeLine" in $$new_props)
      $$invalidate(11, threeLine = $$new_props.threeLine);
    if ("vertical" in $$new_props)
      $$invalidate(25, vertical = $$new_props.vertical);
    if ("wrapFocus" in $$new_props)
      $$invalidate(26, wrapFocus = $$new_props.wrapFocus);
    if ("singleSelection" in $$new_props)
      $$invalidate(27, singleSelection = $$new_props.singleSelection);
    if ("selectedIndex" in $$new_props)
      $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
    if ("radioList" in $$new_props)
      $$invalidate(28, radioList = $$new_props.radioList);
    if ("checkList" in $$new_props)
      $$invalidate(29, checkList = $$new_props.checkList);
    if ("hasTypeahead" in $$new_props)
      $$invalidate(30, hasTypeahead = $$new_props.hasTypeahead);
    if ("component" in $$new_props)
      $$invalidate(12, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(43, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCListFoundation,
    ponyfill: ponyfill_exports,
    onMount,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    Ul,
    Nav,
    closest,
    matches,
    forwardEvents,
    use,
    className,
    nonInteractive,
    dense,
    textualList,
    avatarList,
    iconList,
    imageList,
    thumbnailList,
    videoList,
    twoLine,
    threeLine,
    vertical,
    wrapFocus,
    singleSelection,
    selectedIndex,
    radioList,
    checkList,
    hasTypeahead,
    element: element2,
    instance: instance5,
    items,
    role,
    nav,
    itemAccessorMap,
    selectionDialog,
    addLayoutListener,
    removeLayoutListener,
    component,
    handleItemMount,
    handleItemUnmount,
    handleAction,
    getOrderedList,
    focusItemAtIndex,
    listItemAtIndexHasClass,
    addClassForElementIndex,
    removeClassForElementIndex,
    setAttributeForElementIndex,
    removeAttributeForElementIndex,
    getAttributeFromElementIndex,
    getPrimaryTextAtIndex,
    getListItemIndex,
    layout,
    setEnabled,
    getTypeaheadInProgress,
    getSelectedIndex,
    getFocusedItemIndex,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("nonInteractive" in $$props)
      $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    if ("dense" in $$props)
      $$invalidate(3, dense = $$new_props.dense);
    if ("textualList" in $$props)
      $$invalidate(4, textualList = $$new_props.textualList);
    if ("avatarList" in $$props)
      $$invalidate(5, avatarList = $$new_props.avatarList);
    if ("iconList" in $$props)
      $$invalidate(6, iconList = $$new_props.iconList);
    if ("imageList" in $$props)
      $$invalidate(7, imageList = $$new_props.imageList);
    if ("thumbnailList" in $$props)
      $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
    if ("videoList" in $$props)
      $$invalidate(9, videoList = $$new_props.videoList);
    if ("twoLine" in $$props)
      $$invalidate(10, twoLine = $$new_props.twoLine);
    if ("threeLine" in $$props)
      $$invalidate(11, threeLine = $$new_props.threeLine);
    if ("vertical" in $$props)
      $$invalidate(25, vertical = $$new_props.vertical);
    if ("wrapFocus" in $$props)
      $$invalidate(26, wrapFocus = $$new_props.wrapFocus);
    if ("singleSelection" in $$props)
      $$invalidate(27, singleSelection = $$new_props.singleSelection);
    if ("selectedIndex" in $$props)
      $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
    if ("radioList" in $$props)
      $$invalidate(28, radioList = $$new_props.radioList);
    if ("checkList" in $$props)
      $$invalidate(29, checkList = $$new_props.checkList);
    if ("hasTypeahead" in $$props)
      $$invalidate(30, hasTypeahead = $$new_props.hasTypeahead);
    if ("element" in $$props)
      $$invalidate(14, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(13, instance5 = $$new_props.instance);
    if ("items" in $$props)
      items = $$new_props.items;
    if ("role" in $$props)
      $$invalidate(15, role = $$new_props.role);
    if ("nav" in $$props)
      nav = $$new_props.nav;
    if ("selectionDialog" in $$props)
      $$invalidate(18, selectionDialog = $$new_props.selectionDialog);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("component" in $$props)
      $$invalidate(12, component = $$new_props.component);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*instance, vertical*/
    33562624) {
      $:
        if (instance5) {
          instance5.setVerticalOrientation(vertical);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, wrapFocus*/
    67117056) {
      $:
        if (instance5) {
          instance5.setWrapFocus(wrapFocus);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, hasTypeahead*/
    1073750016) {
      $:
        if (instance5) {
          instance5.setHasTypeahead(hasTypeahead);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, singleSelection*/
    134225920) {
      $:
        if (instance5) {
          instance5.setSingleSelection(singleSelection);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, singleSelection, selectedIndex*/
    151003136) {
      $:
        if (instance5 && singleSelection && getSelectedIndex() !== selectedIndex) {
          instance5.setSelectedIndex(selectedIndex);
        }
    }
  };
  return [
    use,
    className,
    nonInteractive,
    dense,
    textualList,
    avatarList,
    iconList,
    imageList,
    thumbnailList,
    videoList,
    twoLine,
    threeLine,
    component,
    instance5,
    element2,
    role,
    matches,
    forwardEvents,
    selectionDialog,
    handleItemMount,
    handleItemUnmount,
    handleAction,
    getListItemIndex,
    $$restProps,
    selectedIndex,
    vertical,
    wrapFocus,
    singleSelection,
    radioList,
    checkList,
    hasTypeahead,
    layout,
    setEnabled,
    getTypeaheadInProgress,
    getSelectedIndex,
    getFocusedItemIndex,
    getElement,
    slots,
    switch_instance_binding,
    keydown_handler,
    focusin_handler,
    focusout_handler,
    click_handler,
    $$scope
  ];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        nonInteractive: 2,
        dense: 3,
        textualList: 4,
        avatarList: 5,
        iconList: 6,
        imageList: 7,
        thumbnailList: 8,
        videoList: 9,
        twoLine: 10,
        threeLine: 11,
        vertical: 25,
        wrapFocus: 26,
        singleSelection: 27,
        selectedIndex: 24,
        radioList: 28,
        checkList: 29,
        hasTypeahead: 30,
        component: 12,
        layout: 31,
        setEnabled: 32,
        getTypeaheadInProgress: 33,
        getSelectedIndex: 34,
        getFocusedItemIndex: 35,
        getElement: 36
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dense() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dense(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textualList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textualList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get avatarList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set avatarList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imageList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imageList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbnailList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbnailList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get videoList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set videoList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get twoLine() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set twoLine(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get threeLine() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set threeLine(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapFocus() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapFocus(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get singleSelection() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set singleSelection(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedIndex() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radioList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radioList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checkList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checkList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasTypeahead() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasTypeahead(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[31];
  }
  set layout(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setEnabled() {
    return this.$$.ctx[32];
  }
  set setEnabled(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getTypeaheadInProgress() {
    return this.$$.ctx[33];
  }
  set getTypeaheadInProgress(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectedIndex() {
    return this.$$.ctx[34];
  }
  set getSelectedIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getFocusedItemIndex() {
    return this.$$.ctx[35];
  }
  set getFocusedItemIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[36];
  }
  set getElement(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var List_default = List;

// node_modules/@smui/list/dist/Item.svelte
var file = "node_modules/@smui/list/dist/Item.svelte";
function create_if_block(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-deprecated-list-item__ripple");
      add_location(span, file, 56, 15, 1701);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(57:3) {#if ripple}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*ripple*/
    ctx[7] && create_if_block(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[32].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*ripple*/
        ctx2[7]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[     ...(nonInteractive       ? []       : [           [             Ripple,             {               ripple: !input,               unbounded: false,               color:                 (activated || selected) && color == null ? 'primary' : color,               disabled,               addClass,               removeClass,               addStyle,             },           ],         ]),     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-deprecated-list-item': true,     'mdc-deprecated-list-item--activated': activated,     'mdc-deprecated-list-item--selected': selected,     'mdc-deprecated-list-item--disabled': disabled,     'mdc-menu-item--selected': !nav && role === 'menuitem' && selected,     'smui-menu-item--non-interactive': nonInteractive,     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...nav && activated ? { 'aria-current': 'page' } : {}}   {...!nav ? { role } : {}}   {...!nav && role === 'option'     ? { 'aria-selected': selected ? 'true' : 'false' }     : {}}   {...!nav && (role === 'radio' || role === 'checkbox')     ? { 'aria-checked': input && input.checked ? 'true' : 'false' }     : {}}   {...!nav ? { 'aria-disabled': disabled ? 'true' : 'false' } : {}}   data-menu-item-skip-restore-focus={skipRestoreFocus || undefined}   {tabindex}   on:click={action}   on:keydown={handleKeydown}   on:SMUIGenericInput:mount={handleInputMount}   on:SMUIGenericInput:unmount={() => (input = undefined)}   {href}   {...internalAttrs}   {...$$restProps}   >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        .../*nonInteractive*/
        ctx[6] ? [] : [
          [
            dist_default,
            {
              ripple: !/*input*/
              ctx[14],
              unbounded: false,
              color: (
                /*activated*/
                (ctx[1] || /*selected*/
                ctx[0]) && /*color*/
                ctx[5] == null ? "primary" : (
                  /*color*/
                  ctx[5]
                )
              ),
              disabled: (
                /*disabled*/
                ctx[9]
              ),
              addClass: (
                /*addClass*/
                ctx[22]
              ),
              removeClass: (
                /*removeClass*/
                ctx[23]
              ),
              addStyle: (
                /*addStyle*/
                ctx[24]
              )
            }
          ]
        ],
        /*forwardEvents*/
        ctx[20],
        .../*use*/
        ctx[2]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[3]
        ]: true,
        "mdc-deprecated-list-item": true,
        "mdc-deprecated-list-item--activated": (
          /*activated*/
          ctx[1]
        ),
        "mdc-deprecated-list-item--selected": (
          /*selected*/
          ctx[0]
        ),
        "mdc-deprecated-list-item--disabled": (
          /*disabled*/
          ctx[9]
        ),
        "mdc-menu-item--selected": !/*nav*/
        ctx[21] && /*role*/
        ctx[8] === "menuitem" && /*selected*/
        ctx[0],
        "smui-menu-item--non-interactive": (
          /*nonInteractive*/
          ctx[6]
        ),
        .../*internalClasses*/
        ctx[16]
      })
    },
    {
      style: Object.entries(
        /*internalStyles*/
        ctx[17]
      ).map(func).concat([
        /*style*/
        ctx[4]
      ]).join(" ")
    },
    /*nav*/
    ctx[21] && /*activated*/
    ctx[1] ? { "aria-current": "page" } : {},
    !/*nav*/
    ctx[21] ? { role: (
      /*role*/
      ctx[8]
    ) } : {},
    !/*nav*/
    ctx[21] && /*role*/
    ctx[8] === "option" ? {
      "aria-selected": (
        /*selected*/
        ctx[0] ? "true" : "false"
      )
    } : {},
    !/*nav*/
    ctx[21] && /*role*/
    (ctx[8] === "radio" || /*role*/
    ctx[8] === "checkbox") ? {
      "aria-checked": (
        /*input*/
        ctx[14] && /*input*/
        ctx[14].checked ? "true" : "false"
      )
    } : {},
    !/*nav*/
    ctx[21] ? {
      "aria-disabled": (
        /*disabled*/
        ctx[9] ? "true" : "false"
      )
    } : {},
    {
      "data-menu-item-skip-restore-focus": (
        /*skipRestoreFocus*/
        ctx[10] || void 0
      )
    },
    { tabindex: (
      /*tabindex*/
      ctx[19]
    ) },
    { href: (
      /*href*/
      ctx[11]
    ) },
    /*internalAttrs*/
    ctx[18],
    /*$$restProps*/
    ctx[27]
  ];
  var switch_value = (
    /*component*/
    ctx[12]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[33](switch_instance);
    switch_instance.$on(
      "click",
      /*action*/
      ctx[13]
    );
    switch_instance.$on(
      "keydown",
      /*handleKeydown*/
      ctx[25]
    );
    switch_instance.$on(
      "SMUIGenericInput:mount",
      /*handleInputMount*/
      ctx[26]
    );
    switch_instance.$on(
      "SMUIGenericInput:unmount",
      /*SMUIGenericInput_unmount_handler*/
      ctx[34]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & /*nonInteractive, input, activated, selected, color, disabled, addClass, removeClass, addStyle, forwardEvents, use, className, nav, role, internalClasses, internalStyles, style, skipRestoreFocus, tabindex, href, internalAttrs, $$restProps*/
      167726975 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*nonInteractive, input, activated, selected, color, disabled, addClass, removeClass, addStyle, forwardEvents, use*/
        30425703 && {
          use: [
            .../*nonInteractive*/
            ctx2[6] ? [] : [
              [
                dist_default,
                {
                  ripple: !/*input*/
                  ctx2[14],
                  unbounded: false,
                  color: (
                    /*activated*/
                    (ctx2[1] || /*selected*/
                    ctx2[0]) && /*color*/
                    ctx2[5] == null ? "primary" : (
                      /*color*/
                      ctx2[5]
                    )
                  ),
                  disabled: (
                    /*disabled*/
                    ctx2[9]
                  ),
                  addClass: (
                    /*addClass*/
                    ctx2[22]
                  ),
                  removeClass: (
                    /*removeClass*/
                    ctx2[23]
                  ),
                  addStyle: (
                    /*addStyle*/
                    ctx2[24]
                  )
                }
              ]
            ],
            /*forwardEvents*/
            ctx2[20],
            .../*use*/
            ctx2[2]
          ]
        },
        dirty[0] & /*className, activated, selected, disabled, nav, role, nonInteractive, internalClasses*/
        2163531 && {
          class: classMap({
            [
              /*className*/
              ctx2[3]
            ]: true,
            "mdc-deprecated-list-item": true,
            "mdc-deprecated-list-item--activated": (
              /*activated*/
              ctx2[1]
            ),
            "mdc-deprecated-list-item--selected": (
              /*selected*/
              ctx2[0]
            ),
            "mdc-deprecated-list-item--disabled": (
              /*disabled*/
              ctx2[9]
            ),
            "mdc-menu-item--selected": !/*nav*/
            ctx2[21] && /*role*/
            ctx2[8] === "menuitem" && /*selected*/
            ctx2[0],
            "smui-menu-item--non-interactive": (
              /*nonInteractive*/
              ctx2[6]
            ),
            .../*internalClasses*/
            ctx2[16]
          })
        },
        dirty[0] & /*internalStyles, style*/
        131088 && {
          style: Object.entries(
            /*internalStyles*/
            ctx2[17]
          ).map(func).concat([
            /*style*/
            ctx2[4]
          ]).join(" ")
        },
        dirty[0] & /*nav, activated*/
        2097154 && get_spread_object(
          /*nav*/
          ctx2[21] && /*activated*/
          ctx2[1] ? { "aria-current": "page" } : {}
        ),
        dirty[0] & /*nav, role*/
        2097408 && get_spread_object(!/*nav*/
        ctx2[21] ? { role: (
          /*role*/
          ctx2[8]
        ) } : {}),
        dirty[0] & /*nav, role, selected*/
        2097409 && get_spread_object(!/*nav*/
        ctx2[21] && /*role*/
        ctx2[8] === "option" ? {
          "aria-selected": (
            /*selected*/
            ctx2[0] ? "true" : "false"
          )
        } : {}),
        dirty[0] & /*nav, role, input*/
        2113792 && get_spread_object(!/*nav*/
        ctx2[21] && /*role*/
        (ctx2[8] === "radio" || /*role*/
        ctx2[8] === "checkbox") ? {
          "aria-checked": (
            /*input*/
            ctx2[14] && /*input*/
            ctx2[14].checked ? "true" : "false"
          )
        } : {}),
        dirty[0] & /*nav, disabled*/
        2097664 && get_spread_object(!/*nav*/
        ctx2[21] ? {
          "aria-disabled": (
            /*disabled*/
            ctx2[9] ? "true" : "false"
          )
        } : {}),
        dirty[0] & /*skipRestoreFocus*/
        1024 && {
          "data-menu-item-skip-restore-focus": (
            /*skipRestoreFocus*/
            ctx2[10] || void 0
          )
        },
        dirty[0] & /*tabindex*/
        524288 && { tabindex: (
          /*tabindex*/
          ctx2[19]
        ) },
        dirty[0] & /*href*/
        2048 && { href: (
          /*href*/
          ctx2[11]
        ) },
        dirty[0] & /*internalAttrs*/
        262144 && get_spread_object(
          /*internalAttrs*/
          ctx2[18]
        ),
        dirty[0] & /*$$restProps*/
        134217728 && get_spread_object(
          /*$$restProps*/
          ctx2[27]
        )
      ]) : {};
      if (dirty[0] & /*ripple*/
      128 | dirty[1] & /*$$scope*/
      16) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty[0] & /*component*/
      4096 && switch_value !== (switch_value = /*component*/
      ctx2[12])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[33](switch_instance);
          switch_instance.$on(
            "click",
            /*action*/
            ctx2[13]
          );
          switch_instance.$on(
            "keydown",
            /*handleKeydown*/
            ctx2[25]
          );
          switch_instance.$on(
            "SMUIGenericInput:mount",
            /*handleInputMount*/
            ctx2[26]
          );
          switch_instance.$on(
            "SMUIGenericInput:unmount",
            /*SMUIGenericInput_unmount_handler*/
            ctx2[34]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[33](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter = 0;
var func = ([name, value]) => `${name}: ${value};`;
function instance($$self, $$props, $$invalidate) {
  let tabindex;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "color",
    "nonInteractive",
    "ripple",
    "activated",
    "role",
    "selected",
    "disabled",
    "skipRestoreFocus",
    "tabindex",
    "inputId",
    "href",
    "component",
    "action",
    "getPrimaryText",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Item", slots, ["default"]);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { color = void 0 } = $$props;
  let { nonInteractive = (_a = getContext("SMUI:list:nonInteractive")) !== null && _a !== void 0 ? _a : false } = $$props;
  setContext("SMUI:list:nonInteractive", void 0);
  let { ripple = !nonInteractive } = $$props;
  let { activated = false } = $$props;
  let { role = getContext("SMUI:list:item:role") } = $$props;
  setContext("SMUI:list:item:role", void 0);
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { skipRestoreFocus = false } = $$props;
  let { tabindex: tabindexProp = uninitializedValue } = $$props;
  let { inputId = "SMUI-form-field-list-" + counter++ } = $$props;
  let { href = void 0 } = $$props;
  let element2;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let input;
  let addTabindexIfNoItemsSelectedRaf;
  let nav = getContext("SMUI:list:item:nav");
  let { component = nav ? href ? A : Span : Li } = $$props;
  setContext("SMUI:generic:input:props", { id: inputId });
  setContext("SMUI:separator:context", void 0);
  onMount(() => {
    if (!selected && !nonInteractive) {
      let first = true;
      let el = element2;
      while (el.previousSibling) {
        el = el.previousSibling;
        if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && !el.classList.contains("mdc-deprecated-list-item--disabled")) {
          first = false;
          break;
        }
      }
      if (first) {
        addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
      }
    }
    const accessor = {
      _smui_list_item_accessor: true,
      get element() {
        return getElement();
      },
      get selected() {
        return selected;
      },
      set selected(value) {
        $$invalidate(0, selected = value);
      },
      hasClass,
      addClass,
      removeClass,
      getAttr,
      addAttr,
      removeAttr,
      getPrimaryText,
      // For inputs within item.
      get checked() {
        var _a2;
        return (_a2 = input && input.checked) !== null && _a2 !== void 0 ? _a2 : false;
      },
      set checked(value) {
        if (input) {
          $$invalidate(14, input.checked = !!value, input);
        }
      },
      get hasCheckbox() {
        return !!(input && "_smui_checkbox_accessor" in input);
      },
      get hasRadio() {
        return !!(input && "_smui_radio_accessor" in input);
      },
      activateRipple() {
        if (input) {
          input.activateRipple();
        }
      },
      deactivateRipple() {
        if (input) {
          input.deactivateRipple();
        }
      },
      // For select options.
      getValue() {
        return $$restProps.value;
      },
      // For autocomplete
      action,
      get tabindex() {
        return tabindex;
      },
      set tabindex(value) {
        $$invalidate(28, tabindexProp = value);
      },
      get disabled() {
        return disabled;
      },
      get activated() {
        return activated;
      },
      set activated(value) {
        $$invalidate(1, activated = value);
      }
    };
    dispatch(getElement(), "SMUIListItem:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIListItem:unmount", accessor);
    };
  });
  onDestroy(() => {
    if (addTabindexIfNoItemsSelectedRaf) {
      window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(16, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(16, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(17, internalStyles);
      } else {
        $$invalidate(17, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getAttr(name) {
    var _a2;
    return name in internalAttrs ? (_a2 = internalAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(18, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(18, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function addTabindexIfNoItemsSelected() {
    let noneSelected = true;
    let el = element2.getElement();
    while (el.nextElementSibling) {
      el = el.nextElementSibling;
      if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item")) {
        const tabindexAttr = el.attributes.getNamedItem("tabindex");
        if (tabindexAttr && tabindexAttr.value === "0") {
          noneSelected = false;
          break;
        }
      }
    }
    if (noneSelected) {
      $$invalidate(19, tabindex = 0);
    }
  }
  function handleKeydown(e) {
    const isEnter = e.key === "Enter";
    const isSpace = e.key === "Space";
    if (isEnter || isSpace) {
      action(e);
    }
  }
  function handleInputMount(e) {
    if ("_smui_checkbox_accessor" in e.detail || "_smui_radio_accessor" in e.detail) {
      $$invalidate(14, input = e.detail);
    }
  }
  function action(e) {
    if (!disabled) {
      dispatch(getElement(), "SMUI:action", e);
    }
  }
  function getPrimaryText() {
    var _a2, _b, _c;
    const element3 = getElement();
    const primaryText = element3.querySelector(".mdc-deprecated-list-item__primary-text");
    if (primaryText) {
      return (_a2 = primaryText.textContent) !== null && _a2 !== void 0 ? _a2 : "";
    }
    const text = element3.querySelector(".mdc-deprecated-list-item__text");
    if (text) {
      return (_b = text.textContent) !== null && _b !== void 0 ? _b : "";
    }
    return (_c = element3.textContent) !== null && _c !== void 0 ? _c : "";
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(15, element2);
    });
  }
  const SMUIGenericInput_unmount_handler = () => $$invalidate(14, input = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(27, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("nonInteractive" in $$new_props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("ripple" in $$new_props)
      $$invalidate(7, ripple = $$new_props.ripple);
    if ("activated" in $$new_props)
      $$invalidate(1, activated = $$new_props.activated);
    if ("role" in $$new_props)
      $$invalidate(8, role = $$new_props.role);
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("skipRestoreFocus" in $$new_props)
      $$invalidate(10, skipRestoreFocus = $$new_props.skipRestoreFocus);
    if ("tabindex" in $$new_props)
      $$invalidate(28, tabindexProp = $$new_props.tabindex);
    if ("inputId" in $$new_props)
      $$invalidate(29, inputId = $$new_props.inputId);
    if ("href" in $$new_props)
      $$invalidate(11, href = $$new_props.href);
    if ("component" in $$new_props)
      $$invalidate(12, component = $$new_props.component);
    if ("$$scope" in $$new_props)
      $$invalidate(35, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    counter,
    _a,
    onMount,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    Ripple: dist_default,
    A,
    Span,
    Li,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    color,
    nonInteractive,
    ripple,
    activated,
    role,
    selected,
    disabled,
    skipRestoreFocus,
    tabindexProp,
    inputId,
    href,
    element: element2,
    internalClasses,
    internalStyles,
    internalAttrs,
    input,
    addTabindexIfNoItemsSelectedRaf,
    nav,
    component,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    getAttr,
    addAttr,
    removeAttr,
    addTabindexIfNoItemsSelected,
    handleKeydown,
    handleInputMount,
    action,
    getPrimaryText,
    getElement,
    tabindex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("nonInteractive" in $$props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("ripple" in $$props)
      $$invalidate(7, ripple = $$new_props.ripple);
    if ("activated" in $$props)
      $$invalidate(1, activated = $$new_props.activated);
    if ("role" in $$props)
      $$invalidate(8, role = $$new_props.role);
    if ("selected" in $$props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("skipRestoreFocus" in $$props)
      $$invalidate(10, skipRestoreFocus = $$new_props.skipRestoreFocus);
    if ("tabindexProp" in $$props)
      $$invalidate(28, tabindexProp = $$new_props.tabindexProp);
    if ("inputId" in $$props)
      $$invalidate(29, inputId = $$new_props.inputId);
    if ("href" in $$props)
      $$invalidate(11, href = $$new_props.href);
    if ("element" in $$props)
      $$invalidate(15, element2 = $$new_props.element);
    if ("internalClasses" in $$props)
      $$invalidate(16, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(17, internalStyles = $$new_props.internalStyles);
    if ("internalAttrs" in $$props)
      $$invalidate(18, internalAttrs = $$new_props.internalAttrs);
    if ("input" in $$props)
      $$invalidate(14, input = $$new_props.input);
    if ("addTabindexIfNoItemsSelectedRaf" in $$props)
      addTabindexIfNoItemsSelectedRaf = $$new_props.addTabindexIfNoItemsSelectedRaf;
    if ("nav" in $$props)
      $$invalidate(21, nav = $$new_props.nav);
    if ("component" in $$props)
      $$invalidate(12, component = $$new_props.component);
    if ("tabindex" in $$props)
      $$invalidate(19, tabindex = $$new_props.tabindex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*tabindexProp, nonInteractive, disabled, selected, input*/
    268452417) {
      $:
        $$invalidate(19, tabindex = isUninitializedValue(tabindexProp) ? !nonInteractive && !disabled && (selected || input && input.checked) ? 0 : -1 : tabindexProp);
    }
  };
  return [
    selected,
    activated,
    use,
    className,
    style,
    color,
    nonInteractive,
    ripple,
    role,
    disabled,
    skipRestoreFocus,
    href,
    component,
    action,
    input,
    element2,
    internalClasses,
    internalStyles,
    internalAttrs,
    tabindex,
    forwardEvents,
    nav,
    addClass,
    removeClass,
    addStyle,
    handleKeydown,
    handleInputMount,
    $$restProps,
    tabindexProp,
    inputId,
    getPrimaryText,
    getElement,
    slots,
    switch_instance_binding,
    SMUIGenericInput_unmount_handler,
    $$scope
  ];
}
var Item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment2,
      safe_not_equal,
      {
        use: 2,
        class: 3,
        style: 4,
        color: 5,
        nonInteractive: 6,
        ripple: 7,
        activated: 1,
        role: 8,
        selected: 0,
        disabled: 9,
        skipRestoreFocus: 10,
        tabindex: 28,
        inputId: 29,
        href: 11,
        component: 12,
        action: 13,
        getPrimaryText: 30,
        getElement: 31
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activated() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activated(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skipRestoreFocus() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skipRestoreFocus(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    return this.$$.ctx[13];
  }
  set action(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getPrimaryText() {
    return this.$$.ctx[30];
  }
  set getPrimaryText(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[31];
  }
  set getElement(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Item_default = Item;

// node_modules/@smui/list/dist/Text.js
var Text_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__text",
  component: Span
});

// node_modules/@smui/list/dist/PrimaryText.js
var PrimaryText_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__primary-text",
  component: Span
});

// node_modules/@smui/list/dist/SecondaryText.js
var SecondaryText_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__secondary-text",
  component: Span
});

// node_modules/@smui/list/dist/Graphic.svelte
var file2 = "node_modules/@smui/list/dist/Graphic.svelte";
function create_fragment3(ctx) {
  let span;
  let span_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let span_levels = [
    {
      class: span_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-list-item__graphic": true,
        "mdc-menu__selection-group-icon": (
          /*menuSelectionGroup*/
          ctx[4]
        )
      })
    },
    /*$$restProps*/
    ctx[5]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[9](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[3].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*className*/
        2 && span_class_value !== (span_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-deprecated-list-item__graphic": true,
          "mdc-menu__selection-group-icon": (
            /*menuSelectionGroup*/
            ctx2[4]
          )
        }))) && { class: span_class_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Graphic", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  let menuSelectionGroup = getContext("SMUI:list:graphic:menu-selection-group");
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    element: element2,
    menuSelectionGroup,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("menuSelectionGroup" in $$props)
      $$invalidate(4, menuSelectionGroup = $$new_props.menuSelectionGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    menuSelectionGroup,
    $$restProps,
    getElement,
    $$scope,
    slots,
    span_binding
  ];
}
var Graphic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment3, safe_not_equal, { use: 0, class: 1, getElement: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Graphic",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[6];
  }
  set getElement(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Graphic_default = Graphic;

// node_modules/@smui/list/dist/Meta.js
var Meta_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__meta",
  component: Span
});

// node_modules/@smui/list/dist/Label.svelte
var file3 = "node_modules/@smui/list/dist/Label.svelte";
function create_fragment4(ctx) {
  let label;
  let label_class_value;
  let label_for_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let label_levels = [
    {
      class: label_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-list-item__text": true
      })
    },
    {
      for: label_for_value = /*inputProps*/
      ctx[4] ? (
        /*inputProps*/
        ctx[4].id
      ) : void 0
    },
    /*$$restProps*/
    ctx[5]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file3, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[9](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[3].call(null, label))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*className*/
        2 && label_class_value !== (label_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-deprecated-list-item__text": true
        }))) && { class: label_class_value },
        { for: label_for_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  function getElement() {
    return element2;
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    element: element2,
    inputProps,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("inputProps" in $$props)
      $$invalidate(4, inputProps = $$new_props.inputProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    inputProps,
    $$restProps,
    getElement,
    $$scope,
    slots,
    label_binding
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment4, safe_not_equal, { use: 0, class: 1, getElement: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[6];
  }
  set getElement(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/@smui/list/dist/Group.js
var Group_default = classAdderBuilder({
  class: "mdc-deprecated-list-group",
  component: Div
});

// node_modules/@smui/list/dist/Subheader.js
var Subheader_default = classAdderBuilder({
  class: "mdc-deprecated-list-group__subheader",
  component: H3
});

// node_modules/@smui/list/dist/Separator.svelte
function create_fragment5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx[9],
        .../*use*/
        ctx[0]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-list-divider": true,
        "mdc-deprecated-list-divider--padded": (
          /*padded*/
          ctx[2]
        ),
        "mdc-deprecated-list-divider--inset": (
          /*inset*/
          ctx[3]
        ),
        "mdc-deprecated-list-divider--inset-leading": (
          /*insetLeading*/
          ctx[4]
        ),
        "mdc-deprecated-list-divider--inset-trailing": (
          /*insetTrailing*/
          ctx[5]
        ),
        "mdc-deprecated-list-divider--inset-padding": (
          /*insetPadding*/
          ctx[6]
        )
      })
    },
    { role: "separator" },
    /*$$restProps*/
    ctx[10]
  ];
  var switch_value = (
    /*component*/
    ctx[7]
  );
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[12](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = dirty & /*forwardEvents, use, classMap, className, padded, inset, insetLeading, insetTrailing, insetPadding, $$restProps*/
      1663 ? get_spread_update(switch_instance_spread_levels, [
        dirty & /*forwardEvents, use*/
        513 && {
          use: [
            /*forwardEvents*/
            ctx2[9],
            .../*use*/
            ctx2[0]
          ]
        },
        dirty & /*classMap, className, padded, inset, insetLeading, insetTrailing, insetPadding*/
        126 && {
          class: classMap({
            [
              /*className*/
              ctx2[1]
            ]: true,
            "mdc-deprecated-list-divider": true,
            "mdc-deprecated-list-divider--padded": (
              /*padded*/
              ctx2[2]
            ),
            "mdc-deprecated-list-divider--inset": (
              /*inset*/
              ctx2[3]
            ),
            "mdc-deprecated-list-divider--inset-leading": (
              /*insetLeading*/
              ctx2[4]
            ),
            "mdc-deprecated-list-divider--inset-trailing": (
              /*insetTrailing*/
              ctx2[5]
            ),
            "mdc-deprecated-list-divider--inset-padding": (
              /*insetPadding*/
              ctx2[6]
            )
          })
        },
        switch_instance_spread_levels[2],
        dirty & /*$$restProps*/
        1024 && get_spread_object(
          /*$$restProps*/
          ctx2[10]
        )
      ]) : {};
      if (dirty & /*component*/
      128 && switch_value !== (switch_value = /*component*/
      ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[12](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[12](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "padded",
    "inset",
    "insetLeading",
    "insetTrailing",
    "insetPadding",
    "component",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Separator", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { padded = false } = $$props;
  let { inset = false } = $$props;
  let { insetLeading = false } = $$props;
  let { insetTrailing = false } = $$props;
  let { insetPadding = false } = $$props;
  let element2;
  let nav = getContext("SMUI:list:item:nav");
  let context = getContext("SMUI:separator:context");
  let { component = nav || context !== "list" ? Hr : Li } = $$props;
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("padded" in $$new_props)
      $$invalidate(2, padded = $$new_props.padded);
    if ("inset" in $$new_props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("insetLeading" in $$new_props)
      $$invalidate(4, insetLeading = $$new_props.insetLeading);
    if ("insetTrailing" in $$new_props)
      $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
    if ("insetPadding" in $$new_props)
      $$invalidate(6, insetPadding = $$new_props.insetPadding);
    if ("component" in $$new_props)
      $$invalidate(7, component = $$new_props.component);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    Li,
    Hr,
    forwardEvents,
    use,
    className,
    padded,
    inset,
    insetLeading,
    insetTrailing,
    insetPadding,
    element: element2,
    nav,
    context,
    component,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("padded" in $$props)
      $$invalidate(2, padded = $$new_props.padded);
    if ("inset" in $$props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("insetLeading" in $$props)
      $$invalidate(4, insetLeading = $$new_props.insetLeading);
    if ("insetTrailing" in $$props)
      $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
    if ("insetPadding" in $$props)
      $$invalidate(6, insetPadding = $$new_props.insetPadding);
    if ("element" in $$props)
      $$invalidate(8, element2 = $$new_props.element);
    if ("nav" in $$props)
      nav = $$new_props.nav;
    if ("context" in $$props)
      context = $$new_props.context;
    if ("component" in $$props)
      $$invalidate(7, component = $$new_props.component);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    padded,
    inset,
    insetLeading,
    insetTrailing,
    insetPadding,
    component,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    switch_instance_binding
  ];
}
var Separator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment5, safe_not_equal, {
      use: 0,
      class: 1,
      padded: 2,
      inset: 3,
      insetLeading: 4,
      insetTrailing: 5,
      insetPadding: 6,
      component: 7,
      getElement: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Separator",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padded() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padded(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inset() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetLeading() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetLeading(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetTrailing() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetTrailing(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetPadding() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetPadding(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[11];
  }
  set getElement(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Separator_default = Separator;

// node_modules/@smui/list/dist/index.js
var Item2 = Item_default;
var Graphic2 = Graphic_default;
var Label2 = Label_default;
var Separator2 = Separator_default;
var dist_default2 = List_default;
export {
  Graphic2 as Graphic,
  Group_default as Group,
  Item2 as Item,
  Label2 as Label,
  Meta_default as Meta,
  PrimaryText_default as PrimaryText,
  SecondaryText_default as SecondaryText,
  Separator2 as Separator,
  Subheader_default as Subheader,
  Text_default as Text,
  dist_default2 as default
};
//# sourceMappingURL=@smui_list.js.map
