{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/utils/prepare.ts", "../../src/test.ts", "../../src/utils/range.ts", "../../src/score/defaultStrategy.ts", "../../src/utils/toLatin.ts", "../../src/utils/isLeading.ts", "../../src/match.ts", "../../src/array.ts", "../../src/surround.ts"],
  "sourcesContent": ["export { test, TestOptions } from \"./test\";\nexport { match, MatchRange, ScoreContext, ScoreStrategy } from \"./match\";\nexport { filter, sort, FilterOptions, SortOptions } from \"./array\";\nexport { surround, SurroundOptions } from \"./surround\";\n", "import { TestOptions } from \"../test\";\n\n/**\n * This functions is used to throw when query or source is not defined as well\n * as normalizing and lower casing the input strings.\n *\n * @param query The fuzzy query string\n * @param source The fuzzy source string\n * @param opts An options object that can contains `caseSensitive`\n * @returns The reshaped query string and the reshaped source string.\n */\nexport function reshapeInput(\n  query: string,\n  source: string,\n  opts: TestOptions\n): [string, string] {\n  if (typeof query !== \"string\") {\n    throw new TypeError(\"Expecting query to be a string\");\n  }\n\n  if (typeof source !== \"string\") {\n    throw new TypeError(\"Expecting source to be a string\");\n  }\n\n  let reshapedQuery = query.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n  let reshapedSource = source.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n\n  if (!opts.caseSensitive) {\n    reshapedQuery = reshapedQuery.toLowerCase();\n    reshapedSource = reshapedSource.toLowerCase();\n  }\n\n  return [reshapedQuery, reshapedSource];\n}\n", "import { reshapeInput } from \"./utils/prepare\";\n\n/**\n * This represents test options. You can specify if the source string should be\n * lower cased or not (wether you want the test to be case-sensitive or not).\n */\nexport interface TestOptions {\n  caseSensitive?: boolean;\n}\n\n/**\n * Returns wether or not the query fuzzy matches the source. This will returns\n * a boolean.\n *\n * @param query The input query\n * @param source The input source\n * @param opts Options as defined by [[TestOptions]]\n * @returns Wether or not the query fuzzy matches the source\n */\nexport function test(\n  query: string,\n  source: string,\n  opts: TestOptions = {}\n): boolean {\n  const [reshapedQuery, reshapedSource] = reshapeInput(query, source, opts);\n\n  // if no source, then only return true if query is also empty\n  if (!reshapedSource.length) {\n    return !query.length;\n  }\n\n  if (!reshapedQuery.length) {\n    return true;\n  }\n\n  // a bigger query than source will always return false\n  if (reshapedQuery.length > reshapedSource.length) {\n    return false;\n  }\n\n  let queryPos = 0;\n  let sourcePos = 0;\n\n  // loop on source string\n  while (sourcePos < source.length) {\n    const actualSourceCharacter = reshapedSource[sourcePos];\n    const queryCharacterWaitingForMatch = reshapedQuery[queryPos];\n\n    // if actual query character matches source character\n    if (actualSourceCharacter === queryCharacterWaitingForMatch) {\n      // move query pos\n      queryPos += 1;\n    }\n\n    sourcePos += 1;\n  }\n\n  return queryPos === reshapedQuery.length;\n}\n", "import { MatchRange } from \"../match\";\n\n/**\n * Appends to an actual list of ranges a new match. This will only increment\n * the last [[MatchRange]] if the actual match and the last match were\n * siblings.\n *\n * @param ranges The previous ranges array\n * @param sourcePos The position in source that matched\n * @returns The new ranges array\n */\nexport function pushRange(\n  ranges: MatchRange[],\n  sourcePos: number\n): MatchRange[] {\n  const lastRange = ranges[ranges.length - 1];\n\n  if (lastRange && lastRange.stop === sourcePos) {\n    return [\n      ...ranges.slice(0, -1),\n      {\n        start: lastRange.start,\n        stop: sourcePos + 1,\n      },\n    ];\n  } else {\n    return [...ranges, { start: sourcePos, stop: sourcePos + 1 }];\n  }\n}\n", "import { ScoreContext } from \"../match\";\n\n/**\n * Increments a context's score based on the context's values\n * This default strategy is based on\n * https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/\n * A fuzzy matching scoring function should most of the time push a big score\n * when matching a leading letter (ie. a letter that is capital or comes\n * after a separator).\n *\n * @param previousContext The last context given to pushScore. undefined if first match\n * @param context The actual context\n * @returns The new score\n */\nexport function pushScore(\n  previousContext: ScoreContext | undefined,\n  context: ScoreContext\n): number {\n  if (!context) {\n    throw new TypeError(\"Expecting context to be defined\");\n  }\n\n  if (!context.match) {\n    return context.currentScore - 1;\n  }\n\n  let increment = 0;\n\n  if (previousContext && previousContext.match) {\n    increment += 5;\n  }\n\n  if (context.leading) {\n    increment += 10;\n  }\n\n  return context.currentScore + increment;\n}\n", "/**\n * Returns a normalized version of the string. This comes from\n * https://stackoverflow.com/a/37511463. It converts accented characters into\n * two UTF-8 characters (ie. `\u00E8` becomes e and `) and strip the accents.\n *\n * @param str The input string\n * @returns The input string without accents\n */\nexport function toLatin(str: string): string {\n  return str.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n}\n", "import { toLatin } from \"./toLatin\";\n\n/**\n * Returns true when the character is leading; ie. when it's a capital or\n * when it's following a separator character. You might also want to test if\n * the character comes from an alphabet as you wouldn't want to consider a\n * space as a leading character.\n *\n * @param prevChar The character that appears before `char`\n * @param char The actual character you want to test\n * @returns Wether or not the character is leading\n */\nexport function isLeading(prevChar: string, char: string): boolean {\n  const precededBySeparator =\n    prevChar === \"-\" ||\n    prevChar === \"_\" ||\n    prevChar === \" \" ||\n    prevChar === \".\" ||\n    prevChar === \"/\" ||\n    prevChar === \"\\\\\";\n\n  const isCharLeading = char.toUpperCase() === char && /\\w/.test(toLatin(char));\n\n  return precededBySeparator || isCharLeading;\n}\n", "import { reshapeInput } from \"./utils/prepare\";\nimport { pushRange } from \"./utils/range\";\nimport { pushScore } from \"./score/defaultStrategy\";\nimport { isLeading } from \"./utils/isLeading\";\n\n/**\n * This represents a Range that you can get if you call match with `withRanges`\n * set to true. It is composed of indexes of the source string that are matched\n * by the input string.\n */\nexport interface MatchRange {\n  start: number;\n  stop: number;\n}\n\n/**\n * This represents a score context that the scoring function will use to\n * compute the new score. It must include:\n *   - `currentScore` the actual score (ie. the result of the last `pushScore` call or 0)\n *   - `character` the actual source character. It must not be reshaped (ie. lower-cased or normalized)\n *   - `match` wether or not the actual source character is matched by the query\n *   - `leading` wether or not the actual source character is a leading character (as returned by the `isLeading` function)\n */\nexport interface ScoreContext {\n  currentScore: number;\n  character: string;\n  match: boolean;\n  leading: boolean;\n}\n\n/**\n * This represents the signature of the `pushScore` function. It requires the\n * previous context as long as the actual one (as we want to check for\n * concurrent matches), and returns the new score as a number.\n *\n * The scoring function is not returning a number from 0 to 1 but a whole\n * natural number.\n */\nexport type ScoreStrategy = (\n  previousContext: ScoreContext | null,\n  context: ScoreContext\n) => number;\n\n/**\n * Returns wether or not the query fuzzy matches the source\n */\nexport function match(\n  query: string,\n  source: string\n): { match: boolean; ranges: MatchRange[]; score: number };\nexport function match(\n  query: string,\n  source: string,\n  opts: { caseSensitive?: boolean }\n): { match: boolean; ranges: MatchRange[]; score: number };\nexport function match(\n  query: string,\n  source: string,\n  opts: { withScore?: true; caseSensitive?: boolean }\n): { match: boolean; ranges: MatchRange[]; score: number };\nexport function match(\n  query: string,\n  source: string,\n  opts: { withScore?: false; caseSensitive?: boolean }\n): { match: boolean; ranges: MatchRange[] };\nexport function match(\n  query: string,\n  source: string,\n  opts: {\n    withScore?: boolean;\n    caseSensitive?: boolean;\n  } = { withScore: true }\n): { match: boolean; score?: number; ranges: MatchRange[] } {\n  const [reshapedQuery, reshapedSource] = reshapeInput(query, source, opts);\n\n  const withScore = !(opts?.withScore === false);\n\n  // if no source, then only return true if query is also empty\n  if (reshapedSource.length === 0 || reshapedQuery.length === 0) {\n    return {\n      match: query.length === 0,\n      ranges:\n        query.length === 0 ? [{ start: 0, stop: reshapedSource.length }] : [],\n      score: withScore ? (query.length === 0 ? 1 : 0) : undefined,\n    };\n  }\n\n  // a bigger query than source will always return false\n  if (reshapedQuery.length > reshapedSource.length) {\n    return { match: false, ranges: [], score: withScore ? 0 : undefined };\n  }\n\n  let queryPos = 0;\n  let sourcePos = 0;\n  let score = 0;\n  let lastContext: ScoreContext | undefined;\n  let ranges: MatchRange[] = [];\n\n  // loop on source string\n  while (sourcePos < source.length) {\n    const actualSourceCharacter = reshapedSource[sourcePos];\n    const queryCharacterWaitingForMatch = reshapedQuery[queryPos];\n    const match = actualSourceCharacter === queryCharacterWaitingForMatch;\n\n    if (withScore) {\n      // context does not use reshaped as uppercase changes score\n      const previousCharacter = sourcePos > 0 ? source[sourcePos - 1] : \"\";\n\n      const newContext: ScoreContext = {\n        currentScore: score,\n        character: source[sourcePos],\n        match,\n        leading: isLeading(previousCharacter, source[sourcePos]),\n      };\n\n      score = pushScore(lastContext, newContext);\n\n      lastContext = newContext;\n    }\n\n    // if actual query character matches source character\n    if (match) {\n      // push range to result\n      ranges = pushRange(ranges, sourcePos);\n\n      // move query pos\n      queryPos += 1;\n    }\n\n    sourcePos += 1;\n  }\n\n  if (queryPos === reshapedQuery.length) {\n    return {\n      match: true,\n      ranges,\n      score: withScore ? score : undefined,\n    };\n  }\n\n  return {\n    match: false,\n    ranges: [],\n    score: withScore ? 0 : undefined,\n  };\n}\n", "import { test, TestOptions } from \"./test\";\nimport { match } from \"./match\";\n\nexport type ItemIterator<TItem> = (source: TItem) => string;\n\nexport interface FilterOptions<TItem> extends TestOptions {\n  iterator: ItemIterator<TItem>;\n}\n\nexport interface SortOptions<TItem> extends TestOptions {\n  iterator: ItemIterator<TItem>;\n}\n\ntype FilterIterator<TItem> = (item: TItem) => boolean;\ntype SortIterator<TItem> = (leftItem: TItem, rightItem: TItem) => number;\n\n/**\n * This array helper can be used as an `Array.prototype.filter` callback as it\n * will return true or false when passing it a source string.\n */\nexport function filter<TItem>(\n  query: string,\n  options: FilterOptions<TItem>\n): FilterIterator<TItem> {\n  return function (item) {\n    const source = options.iterator(item);\n    return test(query, source, options);\n  };\n}\n\n/**\n * This array helper can be used as an `Array.prototype.sort` callback as it\n * will return `-1`/`0`/`1` when passing it two source strings.\n */\nexport function sort<TItem>(\n  query: string,\n  options: SortOptions<TItem>\n): SortIterator<TItem> {\n  const cacheMap: Map<string, number> = new Map();\n\n  return (leftItem, rightItem) => {\n    const leftSource = options.iterator(leftItem);\n    const rightSource = options.iterator(rightItem);\n\n    const cachedLeftMatch = cacheMap.get(leftSource);\n    const cachedRightMatch = cacheMap.get(rightSource);\n\n    const leftScore = cachedLeftMatch\n      ? cachedLeftMatch\n      : match(query, leftSource, {\n          withScore: true,\n          caseSensitive: options.caseSensitive,\n        }).score;\n\n    const rightScore = cachedRightMatch\n      ? cachedRightMatch\n      : match(query, rightSource, {\n          withScore: true,\n          caseSensitive: options.caseSensitive,\n        }).score;\n\n    if (!cacheMap.has(leftSource)) {\n      cacheMap.set(leftSource, leftScore);\n    }\n\n    if (!cacheMap.has(rightSource)) {\n      cacheMap.set(rightSource, rightScore);\n    }\n\n    if (rightScore === leftScore) {\n      return 0;\n    }\n\n    return rightScore > leftScore ? 1 : -1;\n  };\n}\n", "import { MatchRange } from \"./match\";\n\nexport interface SurroundOptions {\n  result: {\n    ranges: MatchRange[];\n  };\n  prefix?: string;\n  suffix?: string;\n}\n\n/**\n * Surround parts of the string that matched with prefix and suffix.\n * Useful to emphasize the parts that matched.\n */\nexport function surround(source: string, options: SurroundOptions): string {\n  if (typeof source !== \"string\") {\n    throw new TypeError(\"Expecting source to be a string\");\n  }\n\n  if (source.length === 0) {\n    return \"\";\n  }\n\n  if (!options?.result?.ranges?.length) {\n    return source;\n  }\n\n  let result = source;\n  let accumulator = 0;\n\n  for (const range of options.result.ranges) {\n    result = insertAt(result, range.start + accumulator, options.prefix);\n\n    accumulator += (options.prefix ?? \"\").length;\n\n    result = insertAt(result, range.stop + accumulator, options.suffix);\n\n    accumulator += (options.suffix ?? \"\").length;\n  }\n\n  return result;\n}\n\nfunction insertAt(input: string, index: number, patch = \"\"): string {\n  return input.slice(0, index) + patch + input.slice(index);\n}\n"],
  "mappings": ";;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACWO,sBACL,OACA,QACA,MACkB;AAClB,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,IAAI,UAAU;AAAA;AAGtB,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,UAAU;AAAA;AAGtB,MAAI,gBAAgB,MAAM,UAAU,OAAO,QAAQ,oBAAoB;AACvE,MAAI,iBAAiB,OAAO,UAAU,OAAO,QAAQ,oBAAoB;AAEzE,MAAI,CAAC,KAAK,eAAe;AACvB,oBAAgB,cAAc;AAC9B,qBAAiB,eAAe;AAAA;AAGlC,SAAO,CAAC,eAAe;AAAA;;;ACblB,cACL,OACA,QACA,OAAoB,IACX;AACT,QAAM,CAAC,eAAe,kBAAkB,aAAa,OAAO,QAAQ;AAGpE,MAAI,CAAC,eAAe,QAAQ;AAC1B,WAAO,CAAC,MAAM;AAAA;AAGhB,MAAI,CAAC,cAAc,QAAQ;AACzB,WAAO;AAAA;AAIT,MAAI,cAAc,SAAS,eAAe,QAAQ;AAChD,WAAO;AAAA;AAGT,MAAI,WAAW;AACf,MAAI,YAAY;AAGhB,SAAO,YAAY,OAAO,QAAQ;AAChC,UAAM,wBAAwB,eAAe;AAC7C,UAAM,gCAAgC,cAAc;AAGpD,QAAI,0BAA0B,+BAA+B;AAE3D,kBAAY;AAAA;AAGd,iBAAa;AAAA;AAGf,SAAO,aAAa,cAAc;AAAA;;;AC9C7B,mBACL,QACA,WACc;AACd,QAAM,YAAY,OAAO,OAAO,SAAS;AAEzC,MAAI,aAAa,UAAU,SAAS,WAAW;AAC7C,WAAO;AAAA,MACL,GAAG,OAAO,MAAM,GAAG;AAAA,MACnB;AAAA,QACE,OAAO,UAAU;AAAA,QACjB,MAAM,YAAY;AAAA;AAAA;AAAA,SAGjB;AACL,WAAO,CAAC,GAAG,QAAQ,EAAE,OAAO,WAAW,MAAM,YAAY;AAAA;AAAA;;;ACZtD,mBACL,iBACA,SACQ;AACR,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,UAAU;AAAA;AAGtB,MAAI,CAAC,QAAQ,OAAO;AAClB,WAAO,QAAQ,eAAe;AAAA;AAGhC,MAAI,YAAY;AAEhB,MAAI,mBAAmB,gBAAgB,OAAO;AAC5C,iBAAa;AAAA;AAGf,MAAI,QAAQ,SAAS;AACnB,iBAAa;AAAA;AAGf,SAAO,QAAQ,eAAe;AAAA;;;AC5BzB,iBAAiB,KAAqB;AAC3C,SAAO,IAAI,UAAU,OAAO,QAAQ,oBAAoB;AAAA;;;ACGnD,mBAAmB,UAAkB,MAAuB;AACjE,QAAM,sBACJ,aAAa,OACb,aAAa,OACb,aAAa,OACb,aAAa,OACb,aAAa,OACb,aAAa;AAEf,QAAM,gBAAgB,KAAK,kBAAkB,QAAQ,KAAK,KAAK,QAAQ;AAEvE,SAAO,uBAAuB;AAAA;;;AC0CzB,eACL,OACA,QACA,OAGI,EAAE,WAAW,QACyC;AAC1D,QAAM,CAAC,eAAe,kBAAkB,aAAa,OAAO,QAAQ;AAEpE,QAAM,YAAY,CAAE,OAAM,cAAc;AAGxC,MAAI,eAAe,WAAW,KAAK,cAAc,WAAW,GAAG;AAC7D,WAAO;AAAA,MACL,OAAO,MAAM,WAAW;AAAA,MACxB,QACE,MAAM,WAAW,IAAI,CAAC,EAAE,OAAO,GAAG,MAAM,eAAe,YAAY;AAAA,MACrE,OAAO,YAAa,MAAM,WAAW,IAAI,IAAI,IAAK;AAAA;AAAA;AAKtD,MAAI,cAAc,SAAS,eAAe,QAAQ;AAChD,WAAO,EAAE,OAAO,OAAO,QAAQ,IAAI,OAAO,YAAY,IAAI;AAAA;AAG5D,MAAI,WAAW;AACf,MAAI,YAAY;AAChB,MAAI,QAAQ;AACZ,MAAI;AACJ,MAAI,SAAuB;AAG3B,SAAO,YAAY,OAAO,QAAQ;AAChC,UAAM,wBAAwB,eAAe;AAC7C,UAAM,gCAAgC,cAAc;AACpD,UAAM,SAAQ,0BAA0B;AAExC,QAAI,WAAW;AAEb,YAAM,oBAAoB,YAAY,IAAI,OAAO,YAAY,KAAK;AAElE,YAAM,aAA2B;AAAA,QAC/B,cAAc;AAAA,QACd,WAAW,OAAO;AAAA,QAClB;AAAA,QACA,SAAS,UAAU,mBAAmB,OAAO;AAAA;AAG/C,cAAQ,UAAU,aAAa;AAE/B,oBAAc;AAAA;AAIhB,QAAI,QAAO;AAET,eAAS,UAAU,QAAQ;AAG3B,kBAAY;AAAA;AAGd,iBAAa;AAAA;AAGf,MAAI,aAAa,cAAc,QAAQ;AACrC,WAAO;AAAA,MACL,OAAO;AAAA,MACP;AAAA,MACA,OAAO,YAAY,QAAQ;AAAA;AAAA;AAI/B,SAAO;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,OAAO,YAAY,IAAI;AAAA;AAAA;;;AC3HpB,gBACL,OACA,SACuB;AACvB,SAAO,SAAU,MAAM;AACrB,UAAM,SAAS,QAAQ,SAAS;AAChC,WAAO,KAAK,OAAO,QAAQ;AAAA;AAAA;AAQxB,cACL,OACA,SACqB;AACrB,QAAM,WAAgC,IAAI;AAE1C,SAAO,CAAC,UAAU,cAAc;AAC9B,UAAM,aAAa,QAAQ,SAAS;AACpC,UAAM,cAAc,QAAQ,SAAS;AAErC,UAAM,kBAAkB,SAAS,IAAI;AACrC,UAAM,mBAAmB,SAAS,IAAI;AAEtC,UAAM,YAAY,kBACd,kBACA,MAAM,OAAO,YAAY;AAAA,MACvB,WAAW;AAAA,MACX,eAAe,QAAQ;AAAA,OACtB;AAEP,UAAM,aAAa,mBACf,mBACA,MAAM,OAAO,aAAa;AAAA,MACxB,WAAW;AAAA,MACX,eAAe,QAAQ;AAAA,OACtB;AAEP,QAAI,CAAC,SAAS,IAAI,aAAa;AAC7B,eAAS,IAAI,YAAY;AAAA;AAG3B,QAAI,CAAC,SAAS,IAAI,cAAc;AAC9B,eAAS,IAAI,aAAa;AAAA;AAG5B,QAAI,eAAe,WAAW;AAC5B,aAAO;AAAA;AAGT,WAAO,aAAa,YAAY,IAAI;AAAA;AAAA;;;AC3DjC,kBAAkB,QAAgB,SAAkC;AACzE,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,UAAU;AAAA;AAGtB,MAAI,OAAO,WAAW,GAAG;AACvB,WAAO;AAAA;AAGT,MAAI,CAAC,SAAS,QAAQ,QAAQ,QAAQ;AACpC,WAAO;AAAA;AAGT,MAAI,SAAS;AACb,MAAI,cAAc;AAElB,aAAW,SAAS,QAAQ,OAAO,QAAQ;AACzC,aAAS,SAAS,QAAQ,MAAM,QAAQ,aAAa,QAAQ;AAE7D,mBAAgB,SAAQ,UAAU,IAAI;AAEtC,aAAS,SAAS,QAAQ,MAAM,OAAO,aAAa,QAAQ;AAE5D,mBAAgB,SAAQ,UAAU,IAAI;AAAA;AAGxC,SAAO;AAAA;AAGT,kBAAkB,OAAe,OAAe,QAAQ,IAAY;AAClE,SAAO,MAAM,MAAM,GAAG,SAAS,QAAQ,MAAM,MAAM;AAAA;",
  "names": []
}
