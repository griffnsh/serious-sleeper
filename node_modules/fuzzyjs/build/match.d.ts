/**
 * This represents a Range that you can get if you call match with `withRanges`
 * set to true. It is composed of indexes of the source string that are matched
 * by the input string.
 */
export interface MatchRange {
    start: number;
    stop: number;
}
/**
 * This represents a score context that the scoring function will use to
 * compute the new score. It must include:
 *   - `currentScore` the actual score (ie. the result of the last `pushScore` call or 0)
 *   - `character` the actual source character. It must not be reshaped (ie. lower-cased or normalized)
 *   - `match` wether or not the actual source character is matched by the query
 *   - `leading` wether or not the actual source character is a leading character (as returned by the `isLeading` function)
 */
export interface ScoreContext {
    currentScore: number;
    character: string;
    match: boolean;
    leading: boolean;
}
/**
 * This represents the signature of the `pushScore` function. It requires the
 * previous context as long as the actual one (as we want to check for
 * concurrent matches), and returns the new score as a number.
 *
 * The scoring function is not returning a number from 0 to 1 but a whole
 * natural number.
 */
export declare type ScoreStrategy = (previousContext: ScoreContext | null, context: ScoreContext) => number;
/**
 * Returns wether or not the query fuzzy matches the source
 */
export declare function match(query: string, source: string): {
    match: boolean;
    ranges: MatchRange[];
    score: number;
};
export declare function match(query: string, source: string, opts: {
    caseSensitive?: boolean;
}): {
    match: boolean;
    ranges: MatchRange[];
    score: number;
};
export declare function match(query: string, source: string, opts: {
    withScore?: true;
    caseSensitive?: boolean;
}): {
    match: boolean;
    ranges: MatchRange[];
    score: number;
};
export declare function match(query: string, source: string, opts: {
    withScore?: false;
    caseSensitive?: boolean;
}): {
    match: boolean;
    ranges: MatchRange[];
};
